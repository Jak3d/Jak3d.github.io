{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, normalizeStyle as _normalizeStyle, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"content is-medium\"\n};\n\nconst _hoisted_2 = /*#__PURE__*/_createStaticVNode(\"<h3 class=\\\"subtitle is-3\\\">Lez 3</h3><p> Usando il valore di ptr si può accedere al valore memorizzato nella variabile i, pur essendo questo passaggio possibile, tale azione risulta più lento, in quanto esegue una multipla lettura. Più sono i puntatori, più è lunga la &quot;catena&quot; aumentando il tempo necessario per leggere il valore della variabile. <br> In ogni modo bisogna utilizzare la deferenzazione per ottenere il valore in sé. <br><code class=\\\"language-c\\\"> int a = *ptr + 20 </code> (in Questo caso avremmo aumentato il valore di i di 20; abbiamo derefenziato ptr con *). </p><h2 class=\\\"subtitle is-4\\\">Operazioni di controllo flusso</h2> DA SISTEMARE AL MOMENTO E&#39; ORRIBILE <br><pre><code class=\\\"language-c\\\">\\nWhile(expt){\\n ..... \\n } do { \\n .... \\n};\\n    </code></pre><pre><code class=\\\"language-c\\\">\\n\\n    </code></pre><pre><code class=\\\"language-c\\\">\\nwhile(exp){\\n\\n};\\nfor (expr;expr;expr) {\\n\\n};\\n    </code></pre><p> Notare che un&#39;espressione con valore 0 vale False, un&#39;espressione con valore diverso da 0 vale True. <code class=\\\"language-c\\\">While(1){}</code> //causerà un ciclo infinito. <code class=\\\"language-c\\\"> While(a){}</code> //ciclo finchè a != 0. <code class=\\\"language-c\\\">While(a=n){} </code>//assegnamento, finche a=n è diverso da 0. <code class=\\\"language-c\\\"> for(i=0; no_registered(); i++){} </code>. </p><p> Example: <pre><code class=\\\"language-c\\\">\\nif(ptr!= NULL &amp;&amp; *ptr==10){\\n    ... \\n} \\nelse{ \\n    ... \\n} \\n        </code></pre></p><pre><code class=\\\"language-c\\\">\\n#include\\nint main(){\\n    int i = 5;\\n}\\n    </code></pre><pre><code class=\\\"language-c\\\">\\nSwitch(expr){\\n    case a: ...; \\n}; \\n    </code></pre><p> MAI USARE LABEL: <br><pre><code class=\\\"language-c\\\">\\ngoto label; <br>\\n... \\n...\\nlabel: \\n    </code></pre></p><p><code class=\\\"language-c\\\"> .... break; </code> //comporta l&#39;uscita dal ciclo interno attivo (Non esce da tutti i cicli annidati) </p><p> Quando viene dichiarata una stringa (<code class=\\\"language-c\\\"> char *str =&#39;Hello World&#39;</code> ) essendo un array di char, viene aggiunto anche il carattere di fine stringa: <strong> &quot;\\\\0&quot; </strong> come ultimo carattere della stringa. <br> Ogni carattere della stringa avrà il corrispondente valore <strong> ASCII</strong> per indicarne la lettere o il simbolo. char *str &quot;Punterà&quot; <strong>Solo</strong> al primo carattere della stringa; per ottenere H sarà necessario deferenziare la variabile mentre per i successivi bisognerà <strong>sommare</strong> la posizione richiesta all&#39;indirizzo. <code class=\\\"language-c\\\"> *str + 6 == W; //Darà True </code></p><p> Esercizio: Srivere un programma che analizza un testo carattere per carattere e in caso trovi un carattere maiuscolo, la trasforma in minuscolo. </p>\", 16);\n\nconst _hoisted_18 = /*#__PURE__*/_createElementVNode(\"pre\", null, [/*#__PURE__*/_createTextVNode(), /*#__PURE__*/_createElementVNode(\"code\", {\n  class: \"language-c\"\n}, \"\\nint isuppercase(char c){\\n  return c>'A' && c <= 'Z';\\n};\\nchar tolowercase(char c){\\n  return c-('A' - 'a');\\n};\\nint main(){\\n  char c;\\n  char *s = \\\"Hello woRLd! Today's temperature is 34C.\\\";\\n  c=*s;\\n  while(c!='\\\\0'){\\n    if(isuppercase(*c)){\\n      putchar( tolowercase(c));\\n    }\\n    else{ \\n      putchar(c);\\n    }\\n    c=*s++;\\n  }\\n}\\n    \")], -1\n/* HOISTED */\n);\n\nconst _hoisted_19 = [_hoisted_18];\n\nconst _hoisted_20 = /*#__PURE__*/_createStaticVNode(\"<h3 class=\\\"subtitle is-3\\\"> Lezione 4 </h3><h4 class=\\\"subtitle is-4\\\"> Simbolismi in Stringa </h4><pre> <code class=\\\"language-c\\\">\\n      \\n//all in strings\\n&quot;\\\\n : line feed&quot;;\\n&quot;\\\\r : carriage return&quot;;\\n&quot;\\\\t : tabulazione&quot;;\\n&quot;\\\\f : format feed&quot;;\\n&quot;\\\\b : backspace&quot;;\\n&quot;\\\\\\\\ : carattere \\\\&quot;;\\n&quot;\\\\&quot; : carattere &quot; &quot;;\\n&quot;%% : carattere %&quot;;\\n\\n//Alcuni sistemi operativi usano codifiche \\n//differenti per il fine linea:\\nWindows: &quot;\\\\r \\\\n&quot;;\\nUNIX: &quot;\\\\n&quot;;\\nMachintosh: &quot;\\\\r&quot;;\\n</code></pre><h4 class=\\\"subtitle is-4\\\"> Caratteri di controllo in Stringa </h4><p> La stringa può anche possedere dei <strong> caratteri di controllo </strong> designati da %. </p><pre><code class=\\\"language-c\\\">\\n    &quot;%d %i per gli interi&quot;;\\n    &quot;%u per gli interi unsigned&quot;;\\n    &quot;%ld per gli interi long&quot;;\\n    &quot;%c per i caratteri&quot;;\\n    &quot;%s per le stringhe&quot;;\\n    &quot;%f %lf per i float ed i double&quot;;\\n    &quot;%e %E notazione esponenziale&quot;;\\n    &quot;%g %G&quot;;\\n    &quot;%p per i valori puntatori&quot;; \\n  </code></pre><p> I caratteri di formato possono essere preceduti da due numeri separati da un punto (n.m). Essi indicano quante cifre usare rispettivamente per la parte intera e decimale di un numero. Esempio: </p><pre>    <code class=\\\"language-c\\\"> \\ndouble r = rand()/(double)RAND_MAX; \\nprintf(&quot;Inserisci il numero di bytes da allocare: \\\\n&quot;)\\nscanf(&quot;%d&quot;,&amp;n); </code></pre><h3 class=\\\"subtitle is-4\\\"> Input e Output formattato </h3><p> La funzione scanf() legge dallo <strong> stream dei dati</strong> associato allora standard input (stdin): </p><pre><code class=\\\"language-c\\\">\\n  #include &lt;stdio.h&gt;\\n  int scanf(const char *format,  .... );\\n      </code></pre><p> Ogni argomento puntatore deve essere di un tipo appropriato per il valore restituito dalla corrispondente specifica di conversione. Esempio: </p><pre><code class=\\\"language-c\\\"> \\n//Per far uscire il programma dal ciclo (stream di input) premere CTRL+D\\nint n; //size in bytes\\nprintf(&quot;Inserisci numero bytes da allocare \\\\n&quot;);\\nscanf(&quot;%d&quot;,&amp;n);\\n//Stamperà a video il numero di caratteri inseriti\\n        </code></pre><p> Legge dallo stream di input la prima parola presente e la converte in decimale <strong> %d</strong>. Se la conversione ha successo il valore è restituito in n attraverso il puntatore alla variabile. <br> Effettivamente <strong>traduce </strong> i caratteri numerici in valori integer (quando possibile, non accetta caratteri alfabetici). </p><pre> <code class=\\\"language-c\\\">\\nlong cnt;\\nchar c;\\nprintf(&quot;Inserire una stringa e premere CTRL+D per terminare.&quot;)\\nfor (cnt=0; scanf(&quot;%c&quot;,&amp;c)!= EOF; cnt++){\\n  //Scanf ignora gli spazi bianchi\\n  ;\\n}\\nprintf(&quot;Il testo che ha inserito contiene %i caratteri \\\\n&quot;,cnt)\\n  </code></pre><p> Lo scanf verrà subito eseguito ad una velocità estremamente elevata, ma con elemento vuoto, allora si mette in attesa e blocca la code dei processi. La tastiera è gestita dal <strong>SO</strong> ed è quella che attraverso gli interrupt, invia i dati inseriti dalla tastiera. Tutto quello che viene inserito nella tastiera viene salvato nel <strong>Buffer </strong> e poi con invio, viene salvata in qualche punto della memoria. <br><strong> Ripassare sincronizzazione attraverso SO</strong>. LO Stream vuoto <strong> non è </strong> uno stream chiuso. Lo stream chiuso, invece, lo scanf restituisce <strong> EOF </strong>(End of File). </p><h3 class=\\\"subtitle is-4\\\"> Accensione del Computer</h3><h3 class=\\\"subtitle is-2\\\"> Lezione 4</h3><h3 class=\\\"subtitile is-4\\\">Definizioni</h3><p> La direttiva #define definisce nomi simbolici per valori restuali utilizzabili dal programma.</p><pre><code class=\\\"language-c\\\">\\n      #define MAX_NO_STUDENTS 100;\\n      for(i=0; i &lt; MAX_NO_STUDENTS){\\n        ...\\n      }\\n    </code></pre><p>Se una costante simbolica è utilizzata in più mosuli sorgente C serve creare un nuovo file <strong>Intestazione</strong>. </p><pre><code class=\\\"language-c\\\">\\n      #define MAX_NO_STUDENTS 100\\n      #define CLASSROOM_A_CAPACITY 40\\n      #define OVERFLOW (MAX_NO_STUDENTS - CLASSROOM_A_CAPACITY)\\n    </code></pre><p> Il nome di un simbolo ha un numero limitato di caratteri. </p><div><p>Nota: Un header personalizzato non si include con &lt; &gt;, ma indicandone il path relativo o assoluto con &quot; &quot;.</p></div><h3 class=\\\"subtitle is-4\\\">Doppie incusioni</h3><p> Inlusioni di definizio, possono contenere ulteriori inclusioni dentro di loro, causando possibbili <strong>Doppie inclusioni</strong> nello stesso codice. <br><pre><code class=\\\"language-c\\\"> \\n        #ifndef _MATH_MACRO_H \\n        // controlla se esiste già le definizione (if not def)\\n          #define _MATH_MACRO_H\\n          ...\\n          ... \\n        #endif\\n      </code></pre></p><h3 class=\\\"subtitle is-4\\\">Global Variables (Static,External)</h3><p>Le variabili globali sono allocate in fase si compilazione e sono visibili anche da mosuli diversi da quello in cui è definita. <br> Se uso <code class=\\\"language-c\\\"> static int a;</code>, la variabile &quot;a&quot; sarà visibile solo in tutte le parti del programma. <br> Se uso <code class=\\\"language-c\\\">extern int b;</code>, la variabile &quot;b&quot; sarà visibile in qualsiasi modulo esterno, <strong> previa definizione</strong>. </p><h4 class=\\\"subtitle is-4\\\">sizeof()</h4><p>In alcune occasioni è necessario determinare la dimensione di un espressione o di un tipo in termini di Byte</p><pre><code class=\\\"language-c\\\">\\n      sizeof(int);\\n      sizeof(char);\\n      sizeof(*int);\\n    </code></pre><h3>Le Strutture di dati</h3><p>Le strutture C sono: <ul><li>-Gli Array (Sono allocati staticamente al momento di compilazione)(Diverso da JAVA!) <pre><code class=\\\"language-c\\\">\\nint a[10];\\nchar *msg = &quot;OK you entered&quot;; //Punta ad una seguenza di caratteri (al primo elem)\\nchar str[] = {&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;, &#39;\\\\0&#39;}; //ricordare lo &quot;\\\\0&quot;\\nchar *weekdays[] = {&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;}; //Array di puntatori a &quot;Stringhe&quot; (sono sempre char)\\n        </code></pre></li><li>-Lo Struct (Riempito con dei <strong> Campi </strong>) <pre><code class=\\\"language-c\\\">\\n//definizione di una struttura\\nstruct student{ \\n  int matr;\\n  char *firstName;\\n  char *lastName;\\n  int voti[40];\\n  struct address adr; //definito da qualche parte\\n}\\n//definizione di dati con struttura student\\nstruct student pippo,pluto,paperino;\\n        </code></pre></li></ul></p><p>(C&#39;era un bel disegno su array di stringhe (array di puntatori a stringhe): Ricopiare)</p><p>Metodo alternativo per definire un array: <br> <code class=\\\"language-c\\\"> char *weekdays_b = &quot;Mon\\\\Tue\\\\Wed\\\\Thu\\\\Fri\\\\0&quot;</code></p><p>In C il nome di un array indica l&#39;indirizzo del primo elemento</p><ul><li>a,*a, a[0] indicano il primo elemento</li><li>a[3],*(a+3)</li><li>&amp;a[4],a+4</li></ul><p>Non si può modificare &quot;a&quot; in quanto il nome è una variabile di tipo <strong> Const</strong></p><h3 class=\\\"subtitle is-3\\\"> (Lez 4)</h3><p></p><h3 class=\\\"subtitle is-3\\\"> (Lez 6) </h3><h3 class=\\\"subtitle is-4\\\"> Accesso file attraverso stream stdio</h3><p><code class=\\\"language-c\\\"> FILE *f = fopen (&quot;./DivinaCommedia.txt&quot;)</code> <br> La <strong>fopen</strong> restituisce un puntatore allo stream di tipo *FILE. Esso deve essere usato per le seguenti operazioni: </p><pre><code class=\\\"language-c\\\">\\n    fread();\\n    fwrite();\\n    fgets();\\n    fgetc();\\n    fclose();\\n    fseek();\\n    fscanf();\\n    fprintf();\\n  </code></pre><p> Nel stdio.h sono definiti diversi stream: </p><pre><code class=\\\"language-c\\\">\\n  extern FILE *stdin; //standard input, descrittore 0, input file associato al terminale se non specificato altrimenti\\n                      //per leggere file devo assegnargli fopen del file in questione\\n  extern FILE *stdout; //standard output, descrittore 1\\n  extern FILE *stderr; //standard error, descrittore 2\\n  </code></pre><p> Questo comporta che i seguenti sono equivalenti: </p><pre><code class=\\\"language-c\\\">\\nint c;\\nc = fgetc(stdin); //legge dallo stream\\nc = getchar();\\n</code></pre><p>Example:</p><pre><code class=\\\"language-c\\\">\\n  #include &lt;stdio.h&gt;\\n  stdout = fopen(&quot;./La divina commedia.txt&quot;,&quot;a&quot;);\\n\\n  printf(&quot;Hello World&quot;);\\n  frequencies &lt; filein &gt; fileout\\n</code></pre><h3 class=\\\"subtitle is-4\\\"> Allocazione dinamica della memoria </h3><p> Alcune funzioni della libreria stdlib sono per l&#39;allocazione dinamica della memoria dati. <br> Esse sono principalmente le seguenti:</p><pre><code class=\\\"language-c\\\">\\n  void *malloc(size_t size);\\n  void *calloc(size_t nmemb, size_t size);\\n  void *realloc(void *ptr, size_t size);\\n  void free(void *ptr);\\n</code></pre><p><strong>~malloc() </strong> (memory alloc) associa <strong>size</strong> bytes dallo heap e restituisce in caso di successo un puntatore alla memoria allocata. La memoria allocata <strong> non è inizializzata a 0</strong>.</p><p><strong>~calloc() </strong> alloca memoria per un array di nmemb elementi ciascun di dimensione bytes. In caso di successo restituisce un puntatore alla memoria allocata. La memoria allocata <strong>è inizializzata a 0</strong>. Fa il controllo dell&#39;overflow di nmemb*size. </p><p><strong> ~realloc() </strong> modifica la dimensione di un blocco di memoria precedentemente allocato e puntato da ptr alla nuova dimensione {size} bytes. ptr deve essere un puntatore precedentemente restituito da una chiamata a malloc() o calloc() o realloc(). </p><p><strong> ~free() </strong>de-alloca il blocco di memoria puntato da ptr e precedentemente allocato con malloc(),callor() o realloc(). In caso di errore o se nessuna allocazione è stata fatta le funzioni malloc(),calloc(),realloc() restituiscono <strong> NULL</strong>. </p><p><strong>Allocazione dinamica di uno struct</strong></p><pre><code class=\\\"language-c\\\">\\nstruct student *donald = (struct student *) malloc(sizeof(struct student));\\nif (donald != NULL){\\n  donald -&gt; id = 435;\\n  donald -&gt; first_name = &quot;Donald&quot;;\\n  donald -&gt; last_name = &quot;Duck&quot;;\\n}\\nfree(donald);\\n</code></pre><h3 class=\\\"subtitle is-4\\\">Implementazione lista in C</h3><p>Le liste sono strutture dati di natura dinamica, hanno due operazioni che sono inserimento (push()) e prelievo (pop()). Per creare una lista useremo gli Struct e l&#39;allocazione dinamica. </p><pre><code class=\\\"language-c\\\">\\n#include &quot;client.h&quot;\\n\\n//definizione di tipo &#39;l_node&#39; usato per rappresentare i nodi\\n\\ntypedef struct _node{\\n  unsigned int id;\\n  client person;\\n  struct _node *next;\\n} l_node;\\n\\n//definizione del tipo list_cl\\n\\ntypedef struct{\\n  l_node *head;\\n  l_node *tail;\\n} list_cl;\\n\\n#define L_EMPTYLIST_CL {NULL,NULL}\\n</code></pre><p>Definizione di una lista vuota:</p><pre><code class=\\\"language-c\\\">\\n//Variabile utilizzabile soltanto durante la definizione\\nlist_cl class=L_EMPTYLIST_CL; \\n</code></pre><pre><code class=\\\"language-c\\\">\\n(Inside cl_list.h)\\n//Operazioni sulla lista\\nlist_cl l_add_cl(list_cl l, client p); //dichiarazione\\nclient l_rem_cl(list_cl l); //rimozione\\n//oppure\\nlist_cl l_rem_cl(list_cl l, client *p);\\n\\n(Still inside client.h)\\n\\n//definizione del tipo &#39;client&#39;\\ntypedef struct{\\n  char cf[16]; //codice fiscale\\n  char *first_name;\\n  char *last_name;\\n  address adr; //tipo definito altrove\\n} client;\\n</code></pre><p>Eseguire esercizi A.9:</p>\", 67);\n\nconst _hoisted_87 = /*#__PURE__*/_createElementVNode(\"p\", null, \"Implementare le seguenti funzioni sul dato list_cl:\", -1\n/* HOISTED */\n);\n\nconst _hoisted_88 = /*#__PURE__*/_createElementVNode(\"ol\", null, [/*#__PURE__*/_createElementVNode(\"li\", null, \"list_cl l_add_cl(list_cl l, client p): aggiunge il cliente p in coda alla lista l; restituisce la lista stessa, la lista vuota in caso di errore;\"), /*#__PURE__*/_createElementVNode(\"li\", null, \"client l_rem_cl(list_cl l): restituisce il cliente in testa alla lista l, il cliente vuoto se la lista è vuota;\"), /*#__PURE__*/_createElementVNode(\"li\", null, \"int l_is_empty(list_cl l) restituisce 1 se e solo se la lista l è vuota;\"), /*#__PURE__*/_createElementVNode(\"li\", null, \"list_cl l_clear(list_cl l) rimuove tutti gli elementi dalla lista l rilasciando le risorse allocate per essi; restituisce la lista vuota;\"), /*#__PURE__*/_createElementVNode(\"li\", null, \"int l_length(lists_cl l) restituisce il numero di elementi nella lista l.\")], -1\n/* HOISTED */\n);\n\nconst _hoisted_89 = [_hoisted_87, _hoisted_88];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_hoisted_2, _createElementVNode(\"div\", {\n    class: \"button\",\n    onClick: _cache[0] || (_cache[0] = $event => $options.openCard('Es_1'))\n  }, \" Da sostituire ad icona \"), _createElementVNode(\"div\", {\n    style: _normalizeStyle([$data.Es_1 === false ? 'display:none;' : ''])\n  }, _hoisted_19, 4\n  /* STYLE */\n  ), _hoisted_20, _createElementVNode(\"button\", {\n    onClick: _cache[1] || (_cache[1] = $event => $options.openCard('Es_A9')),\n    class: \"button is-warning\"\n  }, \"Show Es. A.9\"), _createElementVNode(\"div\", {\n    style: _normalizeStyle([$data.Es_A9 === false ? 'display:none;' : ''])\n  }, _hoisted_89, 4\n  /* STYLE */\n  )]);\n}","map":{"version":3,"mappings":";;EACOA,KAAK,EAAC;;;;;iCAqGPC,oBAqBW,KArBX,EAqBW,IArBX,EAqBW,+CArBLA,oBAqBD,MArBC,EAqBD;EArBOD,KAAK,EAAC;AAqBb,CArBC,EAAyB,wWAAzB,CAqBK,CArBX;;AAAA;;qBAAAE;;;;iCAuUJD,oBAA0D,GAA1D,EAA0D,IAA1D,EAAG,qDAAH,EAAsD;AAAA;AAAtD;;iCACAA,oBASK,IATL,EASK,IATL,EASK,cARHA,oBACwE,IADxE,EACwE,IADxE,EAAI,mJAAJ,CAQG,eANHA,oBAC2B,IAD3B,EAC2B,IAD3B,EAAI,iHAAJ,CAMG,eAJHA,oBAAiF,IAAjF,EAAiF,IAAjF,EAAI,0EAAJ,CAIG,eAHHA,oBACsE,IADtE,EACsE,IADtE,EAAI,2IAAJ,CAGG,eADHA,oBAAkF,IAAlF,EAAkF,IAAlF,EAAI,2EAAJ,CACG,CATL;;AAAA;;qBADAE,aACAC;;uBA7aAC,oBAwbM,KAxbN,cAwbM,CAvbJC,UAubI,EArVJL,oBAA4E,KAA5E,EAA4E;IAAvED,KAAK,EAAC,QAAiE;IAAvDO,OAAK,sCAAEC,kBAAQ,MAAR,CAAF;EAAkD,CAA5E,EAA8C,0BAA9C,CAqVI,EApVJP,oBAuBM,KAvBN,EAuBM;IAvBAQ,KAAK,mBAAGC,eAAI,KAAJ,GAAI,eAAJ,GAAI,EAAP;EAuBL,CAvBN;;EAAA,CAoVI,EA3TJC,WA2TI,EAdRV,oBAAkF,QAAlF,EAAkF;IAAzEM,OAAK,sCAAEC,kBAAQ,OAAR,CAAF,CAAoE;IAA/CR,KAAK,EAAC;EAAyC,CAAlF,EAA6D,cAA7D,CAcQ,EAbRC,oBAYM,KAZN,EAYM;IAZAQ,KAAK,mBAAGC,gBAAK,KAAL,GAAK,eAAL,GAAK,EAAR;EAYL,CAZN;;EAAA,CAaQ,CAxbN","names":["class","_createElementVNode","_hoisted_18","_hoisted_87","_hoisted_88","_createElementBlock","_hoisted_2","onClick","$options","style","$data","_hoisted_20"],"sourceRoot":"","sources":["C:\\Users\\marro\\OneDrive\\Desktop\\LeonardoMarro-master\\src\\components\\SoLab.vue"],"sourcesContent":["<template>\n  <div class=\"content is-medium\">\n    <h3 class=\"subtitle is-3\">Lez 3</h3>\n    <p>\n      Usando il valore di ptr si può accedere al valore memorizzato nella\n      variabile i, pur essendo questo passaggio possibile, tale azione risulta\n      più lento, in quanto esegue una multipla lettura. Più sono i puntatori,\n      più è lunga la \"catena\" aumentando il tempo necessario per leggere il\n      valore della variabile. <br />\n      In ogni modo bisogna utilizzare la deferenzazione per ottenere il valore\n      in sé. <br />\n      <code class=\"language-c\"> int a = *ptr + 20 </code> (in Questo caso avremmo aumentato il valore di i di 20;\n      abbiamo derefenziato ptr con *).\n    </p>\n    <h2 class=\"subtitle is-4\">Operazioni di controllo flusso</h2>\n\n    DA SISTEMARE AL MOMENTO E' ORRIBILE <br />\n    <pre><code class=\"language-c\">\nWhile(expt){\n ..... \n } do { \n .... \n};\n    </code></pre>\n    <pre><code class=\"language-c\">\n\n    </code></pre>\n    <pre><code class=\"language-c\">\nwhile(exp){\n\n};\nfor (expr;expr;expr) {\n\n};\n    </code></pre>\n    <p>\n      Notare che un'espressione con valore 0\n      vale False, un'espressione con valore diverso da 0 vale True. <code class=\"language-c\">While(1){}</code>\n      //causerà un ciclo infinito. <code class=\"language-c\"> While(a){}</code> //ciclo finchè a != 0.\n      <code class=\"language-c\">While(a=n){} </code>//assegnamento, finche a=n è diverso da 0. <code class=\"language-c\"> for(i=0;\n      no_registered(); i++){} </code>.\n    </p>\n    <p>\n      Example:\n    <pre><code class=\"language-c\">\nif(ptr!= NULL && *ptr==10){\n    ... \n} \nelse{ \n    ... \n} \n        </code></pre>\n\n    </p>\n    <pre><code class=\"language-c\">\n#include\nint main(){\n    int i = 5;\n}\n    </code></pre>\n    <pre><code class=\"language-c\">\nSwitch(expr){\n    case a: ...; \n}; \n    </code></pre>\n\n    <p>\n      MAI USARE LABEL: <br />\n    <pre><code class=\"language-c\">\ngoto label; <br />\n... \n...\nlabel: \n    </code></pre>\n\n    </p>\n    <p>\n      <code class=\"language-c\"> .... break; </code> //comporta l'uscita dal ciclo interno attivo (Non esce da\n      tutti i cicli annidati)\n    </p>\n    <p>\n      Quando viene dichiarata una stringa (<code class=\"language-c\"> char *str ='Hello World'</code> ) essendo un\n      array di char, viene aggiunto anche il carattere di fine stringa:\n      <strong> \"\\0\" </strong> come ultimo carattere della stringa. <br />\n      Ogni carattere della stringa avrà il corrispondente valore\n      <strong> ASCII</strong> per indicarne la lettere o il simbolo. char *str\n      \"Punterà\" <strong>Solo</strong> al primo carattere della stringa; per\n      ottenere H sarà necessario deferenziare la variabile mentre per i\n      successivi bisognerà <strong>sommare</strong> la posizione richiesta\n      all'indirizzo.\n      <code class=\"language-c\">\n*str + 6 == W; //Darà True\n</code>\n\n    </p>\n    <p>\n      Esercizio: Srivere un programma che analizza un testo carattere per\n      carattere e in caso trovi un carattere maiuscolo, la trasforma in\n      minuscolo.\n    </p>\n    <div class=\"button\" @click=\"openCard('Es_1')\"> Da sostituire ad icona </div>\n    <div :style=\"[Es_1 === false ? 'display:none;' :'' ]\">\n      <pre> <code class=\"language-c\">\nint isuppercase(char c){\n  return c>'A' && c &lt;= 'Z';\n};\nchar tolowercase(char c){\n  return c-('A' - 'a');\n};\nint main(){\n  char c;\n  char *s = \"Hello woRLd! Today's temperature is 34C.\";\n  c=*s;\n  while(c!='\\0'){\n    if(isuppercase(*c)){\n      putchar( tolowercase(c));\n    }\n    else{ \n      putchar(c);\n    }\n    c=*s++;\n  }\n}\n    </code></pre>\n    </div>\n\n    <h3 class=\"subtitle is-3\"> Lezione 4 </h3>\n    <h4 class=\"subtitle is-4\"> Simbolismi in Stringa </h4>\n    <pre> <code class=\"language-c\">\n      \n//all in strings\n\"\\n : line feed\";\n\"\\r : carriage return\";\n\"\\t : tabulazione\";\n\"\\f : format feed\";\n\"\\b : backspace\";\n\"\\\\ : carattere \\\";\n\"\\\" : carattere \" \";\n\"%% : carattere %\";\n\n//Alcuni sistemi operativi usano codifiche \n//differenti per il fine linea:\nWindows: \"\\r \\n\";\nUNIX: \"\\n\";\nMachintosh: \"\\r\";\n</code></pre>\n    <h4 class=\"subtitle is-4\"> Caratteri di controllo in Stringa </h4>\n    <p>\n      La stringa può anche possedere dei <strong> caratteri di controllo </strong> designati da %.\n    </p>\n\n    <pre><code class=\"language-c\">\n    \"%d %i per gli interi\";\n    \"%u per gli interi unsigned\";\n    \"%ld per gli interi long\";\n    \"%c per i caratteri\";\n    \"%s per le stringhe\";\n    \"%f %lf per i float ed i double\";\n    \"%e %E notazione esponenziale\";\n    \"%g %G\";\n    \"%p per i valori puntatori\"; \n  </code></pre>\n    <p>\n      I caratteri di formato possono essere preceduti da due numeri separati da un punto (n.m). Essi indicano quante\n      cifre usare rispettivamente per la parte intera e decimale di un numero.\n      Esempio:\n    </p>\n    <pre>\n    <code class=\"language-c\"> \ndouble r = rand()/(double)RAND_MAX; \nprintf(\"Inserisci il numero di bytes da allocare: \\n\")\nscanf(\"%d\",&n); </code></pre>\n    <h3 class=\"subtitle is-4\"> Input e Output formattato </h3>\n\n    <p>\n      La funzione scanf() legge dallo <strong> stream dei dati</strong> associato allora standard input (stdin):\n    </p>\n    <pre><code class=\" language-c\">\n  #include &lt;stdio.h&gt;\n  int scanf(const char *format,  .... );\n      </code></pre>\n    <p>\n      Ogni argomento puntatore deve essere di un tipo appropriato per il valore restituito dalla corrispondente\n      specifica di conversione.\n      Esempio:\n      </p>\n    <pre><code class=\"language-c\"> \n//Per far uscire il programma dal ciclo (stream di input) premere CTRL+D\nint n; //size in bytes\nprintf(\"Inserisci numero bytes da allocare \\n\");\nscanf(\"%d\",&n);\n//Stamperà a video il numero di caratteri inseriti\n        </code></pre>\n        <p>\n    Legge dallo stream di input la prima parola presente e la converte in decimale <strong> %d</strong>. Se la\n    conversione ha successo il valore è restituito in n attraverso il puntatore alla variabile. <br>\n    Effettivamente <strong>traduce </strong> i caratteri numerici in valori integer (quando possibile, non accetta\n    caratteri alfabetici).\n    </p>\n    <pre> <code class=\"language-c\">\nlong cnt;\nchar c;\nprintf(\"Inserire una stringa e premere CTRL+D per terminare.\")\nfor (cnt=0; scanf(\"%c\",&c)!= EOF; cnt++){\n  //Scanf ignora gli spazi bianchi\n  ;\n}\nprintf(\"Il testo che ha inserito contiene %i caratteri \\n\",cnt)\n  </code></pre>\n    <p>\n      Lo scanf verrà subito eseguito ad una velocità estremamente elevata, ma con elemento vuoto, allora si mette in\n      attesa e blocca la code dei processi. La tastiera è gestita dal <strong>SO</strong> ed è quella che attraverso gli\n      interrupt, invia i dati inseriti dalla tastiera. Tutto quello che viene inserito nella tastiera viene salvato nel\n      <strong>Buffer </strong> e poi con invio, viene salvata in qualche punto della memoria. <br>\n      <strong> Ripassare sincronizzazione attraverso SO</strong>. LO Stream vuoto <strong> non è </strong> uno stream chiuso.\n      Lo stream chiuso, invece, lo scanf restituisce <strong> EOF </strong>(End of File).\n    </p>\n    <h3 class=\"subtitle is-4\"> Accensione del Computer</h3>\n    <h3 class=\"subtitle is-2\"> Lezione 4</h3>\n    <h3 class=\"subtitile is-4\">Definizioni</h3>\n    <p> La direttiva #define definisce nomi simbolici per valori restuali utilizzabili dal programma.</p>\n    <pre><code class=\"language-c\">\n      #define MAX_NO_STUDENTS 100;\n      for(i=0; i &lt; MAX_NO_STUDENTS){\n        ...\n      }\n    </code></pre>\n    <p>Se una costante simbolica è utilizzata in più mosuli sorgente C serve creare un nuovo file <strong>Intestazione</strong>. </p>\n    <pre><code class=\"language-c\">\n      #define MAX_NO_STUDENTS 100\n      #define CLASSROOM_A_CAPACITY 40\n      #define OVERFLOW (MAX_NO_STUDENTS - CLASSROOM_A_CAPACITY)\n    </code></pre>\n    <p>\n      Il nome di un simbolo ha un numero limitato di caratteri.\n    </p>\n    <div>\n      <p>Nota: Un header personalizzato non si include con &lt; &gt;, ma indicandone il path relativo o assoluto con \" \".</p>\n    </div>\n    <h3 class=\"subtitle is-4\">Doppie incusioni</h3>\n    <p>\n      \n      Inlusioni di definizio, possono contenere ulteriori inclusioni dentro di loro, causando possibbili <strong>Doppie inclusioni</strong> \n      nello stesso codice. <br>\n      <pre><code class=\"language-c\"> \n        #ifndef _MATH_MACRO_H \n        // controlla se esiste già le definizione (if not def)\n          #define _MATH_MACRO_H\n          ...\n          ... \n        #endif\n      </code></pre>\n    </p>\n    <h3 class=\"subtitle is-4\">Global Variables (Static,External)</h3>\n    <p>Le variabili globali sono allocate in fase si compilazione e sono visibili anche da mosuli diversi da quello in cui è definita.\n      <br> Se uso <code class=\"language-c\"> static int a;</code>, la variabile \"a\" sarà visibile solo in tutte le parti del programma. <br>\n      Se uso <code class=\"language-c\">extern int b;</code>, la variabile \"b\" sarà visibile in qualsiasi modulo esterno, <strong> previa definizione</strong>.\n    </p>\n    <h4 class=\"subtitle is-4\">sizeof()</h4>\n    <p>In alcune occasioni è necessario determinare la dimensione di un espressione o di un tipo in termini di Byte</p>\n    <pre><code class=\"language-c\">\n      sizeof(int);\n      sizeof(char);\n      sizeof(*int);\n    </code></pre>\n    <h3>Le Strutture di dati</h3>\n    <p>Le strutture C sono:\n      <ul>\n        <li>-Gli Array (Sono allocati staticamente al momento di compilazione)(Diverso da JAVA!) <pre><code class=\"language-c\">\nint a[10];\nchar *msg = \"OK you entered\"; //Punta ad una seguenza di caratteri (al primo elem)\nchar str[] = {'H','e','l','l','o', '\\0'}; //ricordare lo \"\\0\"\nchar *weekdays[] = {\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\"}; //Array di puntatori a \"Stringhe\" (sono sempre char)\n        </code></pre></li>\n        <li>-Lo Struct (Riempito con dei <strong> Campi </strong>) <pre><code class=\"language-c\">\n//definizione di una struttura\nstruct student{ \n  int matr;\n  char *firstName;\n  char *lastName;\n  int voti[40];\n  struct address adr; //definito da qualche parte\n}\n//definizione di dati con struttura student\nstruct student pippo,pluto,paperino;\n        </code></pre></li>\n      </ul>\n    </p>\n    <p>(C'era un bel disegno su array di stringhe (array di puntatori a stringhe): Ricopiare)</p>\n    <p>Metodo alternativo per definire un array: <br> <code class=\"language-c\"> char *weekdays_b = \"Mon\\Tue\\Wed\\Thu\\Fri\\0\"</code> </p>\n    <p>In C il nome di un array indica l'indirizzo del primo elemento</p>\n    <ul>\n      <li>a,*a, a[0] indicano il primo elemento</li>\n      <li>a[3],*(a+3)</li>\n      <li>&a[4],a+4</li>\n    </ul>\n    <p>Non si può modificare \"a\" in quanto il nome è una variabile di tipo <strong> Const</strong></p>\n\n\n<h3 class=\"subtitle is-3\"> (Lez 4)</h3>\n<p>\n  \n</p>\n<h3 class=\"subtitle is-3\"> (Lez 6) </h3>\n<h3 class=\"subtitle is-4\"> Accesso file attraverso stream stdio</h3>\n<p>\n  <code class=\"language-c\"> FILE *f = fopen (\"./DivinaCommedia.txt\")</code> <br> La <strong>fopen</strong> restituisce un puntatore \n  allo stream  di tipo *FILE. Esso deve essere usato per le seguenti operazioni:\n</p>\n  <pre><code class=\"language-c\">\n    fread();\n    fwrite();\n    fgets();\n    fgetc();\n    fclose();\n    fseek();\n    fscanf();\n    fprintf();\n  </code></pre>\n\n\n<p>\n  Nel stdio.h sono definiti diversi stream:\n</p>\n  <pre><code class=\"language-c\">\n  extern FILE *stdin; //standard input, descrittore 0, input file associato al terminale se non specificato altrimenti\n                      //per leggere file devo assegnargli fopen del file in questione\n  extern FILE *stdout; //standard output, descrittore 1\n  extern FILE *stderr; //standard error, descrittore 2\n  </code></pre>\n<p>\n  Questo comporta che i seguenti sono equivalenti:\n</p>\n<pre><code class=\"language-c\">\nint c;\nc = fgetc(stdin); //legge dallo stream\nc = getchar();\n</code></pre>\n<p>Example:</p>\n<pre><code class=\"language-c\">\n  #include &lt;stdio.h&gt;\n  stdout = fopen(\"./La divina commedia.txt\",\"a\");\n\n  printf(\"Hello World\");\n  frequencies &lt; filein &gt; fileout\n</code></pre>\n<h3 class=\"subtitle is-4\"> Allocazione dinamica della memoria </h3>\n<p> Alcune funzioni della libreria stdlib sono per l'allocazione dinamica della memoria dati. <br> Esse sono \nprincipalmente le seguenti:</p>\n<pre><code class=\"language-c\">\n  void *malloc(size_t size);\n  void *calloc(size_t nmemb, size_t size);\n  void *realloc(void *ptr, size_t size);\n  void free(void *ptr);\n</code></pre>\n<p><strong>~malloc() </strong> (memory alloc) associa <strong>size</strong> bytes dallo heap e restituisce in caso di successo un puntatore alla memoria\nallocata. La memoria allocata <strong> non è inizializzata a 0</strong>.</p>\n<p> <strong>~calloc() </strong> alloca memoria per un array di nmemb elementi ciascun di dimensione bytes. In caso di successo restituisce  un \n  puntatore alla memoria allocata. La memoria allocata <strong>è inizializzata a 0</strong>. Fa il controllo dell'overflow di \n  nmemb*size.\n</p>\n<p>\n  <strong> ~realloc() </strong> modifica la dimensione di un blocco di memoria precedentemente allocato e puntato da ptr alla nuova dimensione\n  {size} bytes. ptr deve essere un puntatore precedentemente restituito da una chiamata a malloc() o calloc() o realloc().\n</p>\n<p>\n  <strong> ~free() </strong>de-alloca il blocco di memoria puntato da ptr e precedentemente allocato con malloc(),callor() o realloc(). \n  In caso di errore o se nessuna allocazione è stata fatta le funzioni malloc(),calloc(),realloc() restituiscono <strong> NULL</strong>.\n</p>\n<p><strong>Allocazione dinamica di uno struct</strong></p>\n<pre><code class=\"language-c\">\nstruct student *donald = (struct student *) malloc(sizeof(struct student));\nif (donald != NULL){\n  donald -> id = 435;\n  donald -> first_name = \"Donald\";\n  donald -> last_name = \"Duck\";\n}\nfree(donald);\n</code></pre>\n<h3 class=\"subtitle is-4\">Implementazione lista in C</h3>\n<p>Le liste sono strutture dati di natura dinamica, hanno due operazioni che sono inserimento (push()) e prelievo (pop()).\n  Per creare una lista useremo gli Struct e l'allocazione dinamica.\n</p>\n<pre><code class=\"language-c\">\n#include \"client.h\"\n\n//definizione di tipo 'l_node' usato per rappresentare i nodi\n\ntypedef struct _node{\n  unsigned int id;\n  client person;\n  struct _node *next;\n} l_node;\n\n//definizione del tipo list_cl\n\ntypedef struct{\n  l_node *head;\n  l_node *tail;\n} list_cl;\n\n#define L_EMPTYLIST_CL {NULL,NULL}\n</code></pre>\n<p>Definizione di una lista vuota:</p>\n<pre><code class=\"language-c\">\n//Variabile utilizzabile soltanto durante la definizione\nlist_cl class=L_EMPTYLIST_CL; \n</code></pre>\n<pre><code class=\"language-c\">\n(Inside cl_list.h)\n//Operazioni sulla lista\nlist_cl l_add_cl(list_cl l, client p); //dichiarazione\nclient l_rem_cl(list_cl l); //rimozione\n//oppure\nlist_cl l_rem_cl(list_cl l, client *p);\n\n(Still inside client.h)\n\n//definizione del tipo 'client'\ntypedef struct{\n  char cf[16]; //codice fiscale\n  char *first_name;\n  char *last_name;\n  address adr; //tipo definito altrove\n} client;\n</code></pre>\n<p>Eseguire esercizi A.9:</p>\n<button @click=\"openCard('Es_A9')\" class=\"button is-warning\">Show Es. A.9</button>\n<div :style=\"[Es_A9 === false ? 'display:none;' : '']\">\n  <p>Implementare le seguenti funzioni sul dato list_cl:</p>\n  <ol>\n    <li>list_cl l_add_cl(list_cl l, client p): aggiunge il cliente p in coda alla\nlista l; restituisce la lista stessa, la lista vuota in caso di errore;</li>\n    <li>client l_rem_cl(list_cl l): restituisce il cliente in testa alla lista l, il cliente\nvuoto se la lista è vuota;</li>\n    <li>int l_is_empty(list_cl l) restituisce 1 se e solo se la lista l è vuota;</li>\n    <li>list_cl l_clear(list_cl l) rimuove tutti gli elementi dalla lista l\nrilasciando le risorse allocate per essi; restituisce la lista vuota;</li>\n    <li>int l_length(lists_cl l) restituisce il numero di elementi nella lista l.</li>\n  </ol>\n</div>\n  </div>\n\n\n</template>\n<script>\nimport Prism from \"prismjs\";\nimport \"../../node_modules/prismjs/components/prism-c\";\nimport \"prismjs/themes/prism-tomorrow.css\"; \nexport default {\n  name: \"SoLabPage\",\n  data() {\n    return {\n      Es_1: false,\n      Es_A9:false,\n    }\n  },\n\n  // mounted\n  methods: {\n    openCard(card) {\n      switch (card) {\n        case 'Es_1':\n          this.Es_1 = !this.Es_1;\n          console.log(this.Es_1);\n          break;\n        case 'Es_A9':\n          this.Es_A9= !this.Es_A9;\n          console.log(this.Es_A9);\n          break;\n\n        default:\n          break;\n      }\n    }\n  },\n  props: {\n\n  },\n  mounted() {\n    window.Prism = window.Prism || {};\n    window.Prism.manual = true;\n    Prism.highlightAll(); // highlight your code on mount\n  },\n}\n</script>\n<style>\n.token.number,\n.token.tag {\n  all: inherit;\n  color: #905;\n}\n\npre {\n  width: 70%;\n}\n\np {\n  width: 70%;\n}\n\n</style>"]},"metadata":{},"sourceType":"module"}