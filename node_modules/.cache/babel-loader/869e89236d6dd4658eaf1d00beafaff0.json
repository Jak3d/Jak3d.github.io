{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, createVNode as _createVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nimport _imports_0 from '../../immagini/SO/img1_1.png';\nimport _imports_1 from '../../immagini/SO/img1_2.png';\nimport _imports_2 from '../../immagini/SO/img2_1.png';\nimport _imports_3 from '../../immagini/SO/img2_2.png';\nimport _imports_4 from '../../immagini/SO/img2_3.png';\nimport _imports_5 from '../../immagini/SO/img2_4.png';\nimport _imports_6 from '../../immagini/SO/img3_1.png';\nimport _imports_7 from '../../immagini/SO/img3_2.png';\nimport _imports_8 from '../../immagini/SO/img3_3.png';\nimport _imports_9 from '../../immagini/SO/img3_4.png';\n\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<h3 id=\\\"1\\\" class=\\\"subtitle is-2\\\"> Cos&#39;è un sistema operativo? (Lez. 1)</h3><h4 class=\\\"subtitle is-4\\\" id=\\\"1-1\\\">Libri</h4><p> Sistemi Operativi concetti ed esempi di Silver Shatz </p><h4 class=\\\"subtitle is-4\\\" id=\\\"1-2\\\">Cos&#39;è un SO</h4><p> Il sistema operativo è il componente <strong> Software </strong> del computer , senza tale dispositivo, il computer sarebbe una macchina <strong>Hardware</strong>. Un esempio di un computer senza SO fu <strong>Eniac</strong>. </p><img src=\\\"\" + _imports_0 + \"\\\" alt=\\\"\\\" style=\\\"transform:scale(0.70);\\\"><p> Il Sistema operativo gestisce/controlla due principali elementi: <strong> Risorse</strong> e <strong> Controlli</strong></p><p> Le <strong> Risorse </strong> gestite sono: </p><ol><li>Risorse HW (Ram, I/O)</li><li>Risorse SW (File, Code di messaggi, Processi)</li><li>Tempo</li></ol><p> I <strong> Controlli</strong> gestiti sono: <ol><li>Programmi</li><li>Sicurezza</li></ol></p><h3 class=\\\"subtitle is-4 is-centered\\\">Concetti Fondamentali</h3><p> Negli anni &#39;50 nacque il <strong> Primo</strong> SO: <span class=\\\"tag is-info\\\"> IBM SERIE 701</span> Esistono due tipi di processamento input: <strong> SINGLE STREAM</strong> e <strong> BATCH PROCESSING</strong> System (Disegno 1.2) </p><p>Un programma da eseguire è una <strong>Stringa di Istruzioni</strong></p><p>&quot;i&quot; di INPUT (Leggo dato da memoria senza utilizzare la CPU)</p><p>&quot;i&quot; di OUTPUT (Scrivo dato in memoria senza utilizzare la CPU)</p><p>Durante tutto questio persiodo di I/O la CPU rimane <strong>Inattiva</strong>. </p><p>(Disegno 1.3)</p><h3 class=\\\"subtitle is-4\\\"> SO a 2 Jobs</h3><p> Con l&#39;evoluzione della tecnologia si iniziò a caricare 2 Jobs contemporaneamente per sfruttare al meglio la CPU. </p><p>L&#39;SO iniziò a tenere memorizzato il dato di <ins>Chi ha accesso alla CPU</ins>. L&#39;SO de-allocherà la CPU al Job in esecuzione nel momento in cui smetterà di utilizzarla ; in quello stesso momento dedicherà la CPU ad un ulteriore Job che ne necessita.</p><p>Nasce <strong>L&#39;INTERLINING DELLE ISTRUZIONI</strong> (&quot;Infogliamento&quot;)</p><h3 class=\\\"subtitle is-4\\\"> Time-Sharing</h3><p>Con l&#39;avvenire degli anni &#39;60 vennero inventati computer composti da <strong>1 Elaboratore &amp; + Operatori &amp; +Terminali</strong> (Unità I/O)</p><p>Nasce il concetto di <span class=\\\"tag is-info\\\"> File</span></p><p>La nascita del file comporta la nascita di problemi di <strong>Visibilità</strong>.</p><h3 class=\\\"subtitle is-4\\\">Nascita del Personal Computer</h3><p>Negli anni &#39;70 nacque il primo personal computer, la cui nascita rese <strong>Inutile</strong> i sistemi di protezione interni (c&#39;era un singolo utente).</p><h3 class=\\\"subtitle is-4\\\"> Sequenza di accensione del pc</h3><img src=\\\"\" + _imports_1 + \"\\\" alt=\\\"\\\" style=\\\"transform:scale(0.70);\\\"><p> Il SO è denotato dal suo <strong> comportamento reattivo</strong> cioè che reagisce ad eventi ricevuti e li gestisce</p><p>Un evento si differenzia in due categorie: <strong>Trap(sw)</strong> o <strong>Interrupt(hw)</strong></p><h3 class=\\\"subtitle is-2\\\">Gestione degli eventi (Lez 2)</h3><p> L&#39;SO inizia un ciclo <u>Forever</u> caratterizzato da {wait until event --&gt; <u>handle (the event)</u>} a ripetizione infinita. La procedura di <strong>handle</strong> richiede del <u>tempo</u>, per questo bisogna evitare che nuovi eventi generati non vengano persi durtante l&#39;handle precedente. <br> Viene introdotta la <strong>Coda Di Eventi.</strong></p><img src=\\\"\" + _imports_2 + \"\\\" alt=\\\"\\\"><p>L1 selezionato --&gt; viene inviato al componente <strong>Dispatcher</strong> (Smistatore) del SO come input, lo dispatcher individua l&#39;handler più adatto per gestire L1</p><h3 class=\\\"subtitle is-4\\\"> Array di Interrupt</h3><p> L&#39;SO sa gestire n tipologie di eventi predefiniti: </p><img src=\\\"\" + _imports_3 + \"\\\" alt=\\\"\\\"><p> Gli indirizzi i vengono salvati nel <strong>Vettore interruzioni</strong> (su RAM)</p><img src=\\\"\" + _imports_4 + \"\\\" alt=\\\"\\\"><h3 class=\\\"subtitle is-4\\\"> Context Switch </h3><p>Siccome sia un codice che l&#39;SO hanno bisogno della CPU, occore usare il <strong>Context Switch</strong>: </p><ol><li>Context Switch &quot;congela&quot; il codice per liberare la CPU per l&#39;SO e permettergli di gestire l&#39;evento</li><li>Al fine della gestione degli eventi presenti, si riprende l&#39;esecuzione del cosice</li></ol><img src=\\\"\" + _imports_5 + \"\\\" alt=\\\"\\\"><p> Nella gerarchi della memoria i registri sono i più veloci, ma con altrettanto alto costo; al fondo vi sono i nastri magnetici. L&#39;SO è incaricato di gestire <strong>la CPU</strong>,<strong>le memorie</strong>,<strong>i dispositivi</strong> (sia i controller che i driver). </p><h3 class=\\\"subtitle is-4\\\">Dual Mode</h3><h3 class=\\\"subtitle is-5\\\"> Modello a Livelli </h3><p>Nel modello a livelli l&#39; <strong>instruzion set</strong> viene partizionato in due insiemi: <strong>Istruzioni comuni e Istruzioni privilegiate</strong>. Nel caso si volesse utilizzare un&#39;istruzione privilegiata, sarebbe necessario eseguire una <strong>System Call</strong> per chiederne l&#39;esecuzione da parte dell&#39;SO. <br> In architettura viene impostato un <strong>bit di modalità</strong> che alterna tra modalità <strong>utente</strong> e modalità <strong>kernel.</strong></p><br> Ex:printf --&gt; SystemCall --&gt; Modalità kernel (dopo eventuali controlli). <h3 class=\\\"subtitle is-4\\\"> System Call </h3><p> Il System Call serve a 5 categorie: <ol><li> Controllo/Gestione dei Processi</li><li> Controllo/Gestione dei File</li><li> Controllo/Gestione dei Dispositivi</li><li> Controllo/Gestione delle Informazioni</li><li> Controllo/Gestione della Comunicazione</li></ol></p><p> (1) Processi: <br> Programma --&gt; esecuzione 1 --&gt; Processo &lt;-- Risorse assegnate da SO</p><p> (2) File: <br> La manipolazione dei file è <strong>Critica</strong>, servono dei criteri di sicurezza. <br> l&#39;invocazione di un file evoca numerose SystemCall:</p><ol><li>Avvia il nuovo processo di copiatura</li><li>Apre progetto.c</li><li>Apre progetto2.c</li><li>Ciclo di lettura e Scrittura (tutte SysCall)</li><li>Chiusura progetto.c</li><li>Chiusura progetto2.c</li><li>Comunicazione a terminale</li><li>Terminazione del processo</li></ol><p> Per vedere le SysCall usare comando: &quot;strace {comando} -cw&quot; <br> Execve è una SysCall importante</p><h3 class=\\\"subtitle is-4\\\">Come si implementa un SO</h3><p><ol><li>Scegliere il linguaggio ad alto livello (Non Assembly) per incrementare la portabilità del SO</li><li>Generare politiche/Strategie che si appoggiano a <strong>Specifici Meccanismi</strong> per svolgere le operazioni di controllo e la gestione di Risorse</li></ol> La Politica è la regola che si vuole implementare, il Meccanismo è lo strumento con la quale si può fare l&#39;implementazione (Neutri rispetto alla politica) </p>\", 58);\n\nconst _hoisted_59 = /*#__PURE__*/_createStaticVNode(\"<h3 class=\\\"subtitle is-2\\\">Stratificazione del Sistema (Lez 3) </h3><p> Per motivi di sicurezza è stata implementata la stratificazione a livelli sel SO, in questo modo un certo livello K potrà comunicare solo con il livello K+1 e il K-1 fino ad arrivare al HW che comunicherà soltanto con il livello 1. Il livello più in alto si chiama <strong> Ambiente di lavoro utente.</strong></p><h3 class=\\\"subtitle is-4 is-centered\\\"> Struttura Unix</h3><img src=\\\"\" + _imports_6 + \"\\\" alt=\\\"\\\"><table class=\\\"table\\\"><thead><th>Vantaggi</th><th>Svantaggi</th></thead><tbody><tr><td>Tecnica Semplice (Stratificata)</td><td>Esecuzione &quot;Inefficiente&quot;</td></tr><tr><td>Semplice Realizzazione</td><td>Difficile Organizzazione dei diritti sugli stati</td></tr><tr><td><strong>Semplice Debugging</strong></td></tr></tbody></table><h3 class=\\\"subtitle is-4\\\"> Macchine Virtuali </h3><img src=\\\"\" + _imports_7 + \"\\\" alt=\\\"\\\"><h3 class=\\\"subtitle is-4\\\"> Tecnica Micro-Kernel</h3><p>Un&#39;alternativa al sistema a livelli è la <strong>tecnica micro-kernel</strong>. <br> Il micro-kernel avrà il compito di gestire: <ul><li>Processi</li><li>Memoria</li><li>Comunicazione (Scambio di messaggi)</li></ul> La tecnica micro-kernelpremette l&#39;aggiunta di <strong>Moduli Aggiunti</strong></p><h3 class=\\\"subtitle is-4\\\">SO Customization</h3><p> I moduli aggiunti <strong>non possono comunicare tra di loro</strong> in quanto viene preso in considerazione che non sempre tutti i moduli aggiuntivi utilizzati saranno scaricati sul SO. <br> Un modulo che richiede l&#39;utilizzo di un altro (Cliente), deve passare attraverso l&#39;SO e chiedere servizi ad un altro modulo (Server). <br> Tutto questo passaggio causa un grande problema di <strong>Disaccoppiamento</strong>. <br> Il più grande problema è causato dalla possibile comparsa di un <strong>Bottleneck</strong> per il kernel, causando un rallentamento dell&#39;esecuzione. <br> Se un modulo crolla, gli altri rimangono intoccati. </p><h3 class=\\\"subtitle is-4\\\">Organizzazione Kernel a Moduli</h3><p> In questa organizzazione il kernel è <strong>Ridotto</strong>, ma i moduli hanno una loro interfaccia per essere <strong> utilizzati da altri moduli</strong>. <br> {Comando: &quot;ls mod&quot;} </p><h3 class=\\\"subtitle is-4\\\">Processi</h3><p> Un Programma è un <strong>file</strong> che viene <strong>eseguito</strong>. Durante l&#39;esecuzione un programma utilizza risorse RAM e CPU. </p><img src=\\\"\" + _imports_8 + \"\\\" alt=\\\"\\\"><p> Ricordare che quando più processi vengono eseguiti in contemporanea, si chiama parallelismo virtuale, in quanto sono eseguiti in &quot;finta simultanea&quot;. </p><p><ul><li>P1 passa ad attesa e si libera la CPU</li><li>P2 passa ad esecuzione</li></ul></p><p> Ogno processo viene identificato attraverso il <strong>PID</strong> (Process identifier (numero univoco)). <br> Inoltre ogni porcesso possiede anche il PCB, ovvero una lista che specifica lo stato e tutte le informazioni necessarie a ripristinare il processo, quando viene ripreso. </p><h3 class=\\\"subtitle is-4\\\">Stati dei Processi</h3><img src=\\\"\" + _imports_9 + \"\\\" alt=\\\"\\\"><p><ul><li>-A termine dell&#39;esecuzione di un processo de-alloca tutto ciò che era assegnato e le dedica ad un altro Processo;</li><li>-Waiting è in attesa di qualsoa di esterno, nel mentre de-alloca le sue risors;</li><li>*Solo <strong>alucuni </strong>sistemi operativi possono <strong>sottrarre CPU</strong> ad un elemento in <strong>Esecuzione.</strong></li></ul></p><h3 class=\\\"subtitle is-4\\\"> Context Switch</h3><p> Se un processo P1 viene interrotto , la parte già eseguita viene <strong>Salvata nel PCB</strong>, dove verrà poi riottennuta quando dovrà riprendere. <br> Nel PCB si trovano tutti i registri da recuperare per riprendere in futuro l&#39;esecuzione dal punto in cui si era interrotta. <br></p><p><strong>Transizione da Running a Terminato </strong></p><ul><li>-Un processo termina a causa di una SysCall (Terminazione Naturale SysCallExit);</li><li>-In caso di Errore --&gt; SysSall:Abort;</li><li>-Processo &quot;uccide un altro processo&quot; --&gt; SysCall:Kill;</li><li>Utente uccide un processo --&gt; SysCall:</li></ul><p><strong> Transizione da Running a Waiting (4 casi)</strong></p><ol><li>Invocazione operazione I/O;</li><li>Sospensione Volontaria;</li><li>Sospensione in attesa di un evento;</li><li>Sincronizzazione (Semafori)</li></ol><p><strong> Strutture di Dati di Supporto</strong></p><ol><li>Ready: Nella coda ready;</li><li>I/O: Nella coda dispositivo (1 per dispositivo);</li><li>Sincronizzazione semafori: Nella coda Semafori;</li></ol><h3 class=\\\"subtitle is-4\\\">Scheduling</h3><p>&quot;Identificare il prossimo processo a cui assegnare una risorsa&quot;</p><p>3 Tipi:</p><ul><li>-Scheduling a lungo termine;</li><li>-Scheduling a medio termine;</li><li>-Scheduling a corto termine;</li></ul>\", 34);\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_vue_mathjax = _resolveComponent(\"vue-mathjax\");\n\n  return _openBlock(), _createElementBlock(\"div\", null, [_hoisted_1, _createElementVNode(\"p\", null, [_createVNode(_component_vue_mathjax, {\n    formula: $data.formula\n  }, null, 8\n  /* PROPS */\n  , [\"formula\"])]), _hoisted_59]);\n}","map":{"version":3,"mappings":";OAeaA,gBAAkC;OAgDlCC,gBAAkC;OAUlCC,gBAAkC;OAOlCC,gBAAkC;OAElCC,gBAAkC;OAOlCC,gBAAkC;OAyDlCC,gBAAkC;OAqBlCC,gBAAkC;OA4BlCC,gBAAkC;OAelCC,gBAAkC;;;;;;;;;uBAjN3CC,oBA4PM,KA5PN,EA4PM,IA5PN,EA4PM,CA1PFC,UA0PE,EArHFC,oBAGI,GAHJ,EAGI,IAHJ,EAGI,CADAC,aAA8CC,sBAA9C,EAA8C;IAAhCC,OAAO,EAAEC;EAAuB,CAA9C,EAA8B,IAA9B,EAA8B;EAAA;EAA9B,EAA8B,WAA9B,CACA,CAHJ,CAqHE,EAjHFC,WAiHE,CA5PN","names":["_imports_0","_imports_1","_imports_2","_imports_3","_imports_4","_imports_5","_imports_6","_imports_7","_imports_8","_imports_9","_createElementBlock","_hoisted_1","_createElementVNode","_createVNode","_component_vue_mathjax","formula","$data","_hoisted_59"],"sourceRoot":"","sources":["C:\\Users\\marro\\OneDrive\\Desktop\\LeonardoMarro-master\\src\\components\\SistemiOperativi.vue"],"sourcesContent":["<template >\n    <div>\n\n        <h3  id=\"1\" class=\"subtitle is-2\"> Cos'è un sistema operativo? (Lez. 1)</h3>\n        <h4 class=\"subtitle is-4\" id=\"1-1\">Libri</h4>\n        <p>\n            Sistemi Operativi concetti ed esempi di Silver Shatz\n        </p>\n        <h4 class=\"subtitle is-4\" id=\"1-2\">Cos'è un SO</h4>\n        <p>\n            Il sistema operativo è il componente <strong> Software </strong> del computer , senza tale dispositivo, il\n            computer\n            sarebbe una macchina <strong>Hardware</strong>. Un esempio di un computer senza SO fu\n            <strong>Eniac</strong>.\n        </p>\n        <img src=\"../../immagini/SO/img1_1.png\" alt=\"\" style=\"transform:scale(0.70)\">\n        <p>\n            Il Sistema operativo gestisce/controlla due principali elementi: <strong> Risorse</strong> e <strong>\n                Controlli</strong>\n        </p>\n        <p>\n            Le <strong> Risorse </strong> gestite sono:\n        </p>\n        <ol>\n            <li>Risorse HW (Ram, I/O)</li>\n            <li>Risorse SW (File, Code di messaggi, Processi)</li>\n            <li>Tempo</li>\n        </ol>\n        <p>\n            I <strong> Controlli</strong> gestiti sono:\n        <ol>\n            <li>Programmi</li>\n            <li>Sicurezza</li>\n        </ol>\n        </p>\n        <h3 class=\"subtitle is-4 is-centered\">Concetti Fondamentali</h3>\n        <p>\n            Negli anni '50 nacque il <strong> Primo</strong> SO: <span class=\"tag is-info\"> IBM SERIE 701</span>\n            Esistono due tipi di processamento input: <strong> SINGLE STREAM</strong> e <strong> BATCH\n                PROCESSING</strong> System\n            (Disegno 1.2)\n        </p>\n        <p>Un programma da eseguire è una <strong>Stringa di Istruzioni</strong> </p>\n        <p>\"i\" di INPUT (Leggo dato da memoria senza utilizzare la CPU)</p>\n        <p>\"i\" di OUTPUT (Scrivo dato in memoria senza utilizzare la CPU)</p>\n        <p>Durante tutto questio persiodo di I/O la CPU rimane <strong>Inattiva</strong>. </p>\n        <p>(Disegno 1.3)</p>\n        <h3 class=\"subtitle is-4\"> SO a 2 Jobs</h3>\n        <p> Con l'evoluzione della tecnologia si iniziò a caricare 2 Jobs contemporaneamente per sfruttare al meglio la\n            CPU. </p>\n        <p>L'SO iniziò a tenere memorizzato il dato di <ins>Chi ha accesso alla CPU</ins>. L'SO de-allocherà la CPU al\n            Job in esecuzione nel momento in cui smetterà di utilizzarla\n            ; in quello stesso momento dedicherà la CPU ad un ulteriore Job che ne necessita.</p>\n        <p>Nasce <strong>L'INTERLINING DELLE ISTRUZIONI</strong> (\"Infogliamento\")</p>\n        <h3 class=\"subtitle is-4\"> Time-Sharing</h3>\n        <p>Con l'avvenire degli anni '60 vennero inventati computer composti da <strong>1 Elaboratore & + Operatori &\n                +Terminali</strong> (Unità I/O)</p>\n        <p>Nasce il concetto di <span class=\"tag is-info\"> File</span></p>\n        <p>La nascita del file comporta la nascita di problemi di <strong>Visibilità</strong>.</p>\n        <h3 class=\"subtitle is-4\">Nascita del Personal Computer</h3>\n        <p>Negli anni '70 nacque il primo personal computer, la cui nascita rese <strong>Inutile</strong> i sistemi di\n            protezione interni (c'era un singolo utente).</p>\n        <h3 class=\"subtitle is-4\"> Sequenza di accensione del pc</h3>\n        <img src=\"../../immagini/SO/img1_2.png\" alt=\"\" style=\"transform:scale(0.70)\">\n        <p> Il SO è denotato dal suo <strong> comportamento reattivo</strong> cioè che reagisce ad eventi ricevuti e li gestisce</p>\n        <p>Un evento si differenzia in due categorie: <strong>Trap(sw)</strong> o <strong>Interrupt(hw)</strong></p>\n        <h3 class=\"subtitle is-2\">Gestione degli eventi (Lez 2)</h3>\n        <p>\n            L'SO inizia un ciclo <u>Forever</u> caratterizzato da {wait until event --> <u>handle (the event)</u>} a ripetizione infinita.\n            La procedura di <strong>handle</strong> richiede del <u>tempo</u>, per questo bisogna evitare che nuovi eventi generati non vengano persi durtante \n            l'handle precedente. <br>\n            Viene introdotta la <strong>Coda Di Eventi.</strong>\n        </p>\n        <img src=\"../../immagini/SO/img2_1.png\" alt=\"\">\n        <p>L1 selezionato --> viene inviato al componente <strong>Dispatcher</strong> (Smistatore) del SO come input, \n            lo dispatcher individua l'handler più adatto per gestire L1</p>\n        <h3 class=\"subtitle is-4\"> Array di Interrupt</h3>\n        <p>\n            L'SO sa gestire n tipologie di eventi predefiniti:\n        </p>\n        <img src=\"../../immagini/SO/img2_2.png\" alt=\"\">\n        <p> Gli indirizzi i vengono salvati nel <strong>Vettore interruzioni</strong> (su RAM)</p>\n        <img src=\"../../immagini/SO/img2_3.png\" alt=\"\">\n        <h3 class=\"subtitle is-4\"> Context Switch </h3>\n        <p>Siccome sia un codice che l'SO hanno bisogno della CPU, occore usare il <strong>Context Switch</strong>: </p>\n        <ol>\n            <li>Context Switch \"congela\" il codice per liberare la CPU per l'SO e permettergli di gestire l'evento</li>\n            <li>Al fine della gestione degli eventi presenti, si riprende l'esecuzione del cosice</li>\n        </ol>\n        <img src=\"../../immagini/SO/img2_4.png\" alt=\"\">\n        <p>\n            Nella gerarchi della memoria i registri sono i più veloci, ma con altrettanto alto costo; al fondo vi sono i nastri magnetici.\n            L'SO è incaricato di gestire <strong>la CPU</strong>,<strong>le memorie</strong>,<strong>i dispositivi</strong> (sia i controller che i driver).\n        </p>\n        <h3 class=\"subtitle is-4\">Dual Mode</h3>\n        <h3 class=\"subtitle is-5\"> Modello a Livelli </h3>\n        <p>Nel modello a livelli l' <strong>instruzion set</strong> viene partizionato in due insiemi: <strong>Istruzioni comuni e Istruzioni privilegiate</strong>. \n        Nel caso si volesse utilizzare un'istruzione privilegiata, sarebbe necessario eseguire una <strong>System Call</strong> per chiederne l'esecuzione da parte dell'SO. <br>\n        In architettura viene impostato un <strong>bit di modalità</strong> che alterna tra modalità <strong>utente</strong> e modalità <strong>kernel.</strong></p>\n        <br> Ex:printf --> SystemCall --> Modalità kernel (dopo eventuali controlli).\n        <h3 class=\"subtitle is-4\"> System Call </h3>\n        <p>\n            Il System Call serve a 5 categorie:\n            <ol>\n                <li> Controllo/Gestione dei Processi</li>\n                <li> Controllo/Gestione dei File</li>\n                <li> Controllo/Gestione dei Dispositivi</li>\n                <li> Controllo/Gestione delle Informazioni</li>\n                <li> Controllo/Gestione della Comunicazione</li>\n            </ol>\n        </p>\n        <p> (1) Processi: <br>\n            Programma --> esecuzione 1 --> Processo &lt;-- Risorse assegnate da SO</p>\n        <p> (2) File: <br>\n            La manipolazione dei file è <strong>Critica</strong>, servono dei criteri di sicurezza. <br>\n            l'invocazione di un file evoca numerose SystemCall:</p>\n            <ol>\n                <li>Avvia il nuovo processo di copiatura</li>\n                <li>Apre progetto.c</li>\n                <li>Apre progetto2.c</li>\n                <li>Ciclo di lettura e Scrittura (tutte SysCall)</li>\n                <li>Chiusura progetto.c</li>\n                <li>Chiusura progetto2.c</li>\n                <li>Comunicazione a terminale</li>\n                <li>Terminazione del processo</li>\n            </ol>\n            <p> Per vedere le SysCall usare comando: \"strace {comando} -cw\" <br>\n            Execve è una SysCall importante</p>\n        <h3 class=\"subtitle is-4\">Come si implementa un SO</h3>\n        <p>\n            <ol>\n                <li>Scegliere il linguaggio ad alto livello (Non Assembly) per incrementare la portabilità del SO</li>\n                <li>Generare politiche/Strategie che si appoggiano a <strong>Specifici Meccanismi</strong> per svolgere le operazioni di controllo e la gestione di Risorse</li>\n            </ol>\n            La Politica è la regola che si vuole implementare, il Meccanismo è lo strumento con la quale si può fare l'implementazione (Neutri rispetto alla politica)\n        </p>\n        <p>\n            \n            <vue-mathjax :formula=\"formula\"></vue-mathjax>\n        </p>\n        <h3 class=\"subtitle is-2\">Stratificazione del Sistema (Lez 3) </h3>\n        <p>\n            Per motivi di sicurezza è stata implementata la stratificazione a livelli sel SO, in questo modo un certo livello K potrà comunicare solo con \n            il livello K+1 e il K-1 fino ad arrivare al HW che comunicherà soltanto con il livello 1. Il livello più in alto si chiama <strong> Ambiente di lavoro utente.</strong>\n        </p>\n        <h3 class=\"subtitle is-4 is-centered\"> Struttura Unix</h3>\n        <img src=\"../../immagini/SO/img3_1.png\" alt=\"\">\n        <table class=\"table\">\n            <thead>\n                <th>Vantaggi</th>\n                <th>Svantaggi</th>\n            </thead>\n            <tbody>\n                <tr>\n                    <td>Tecnica Semplice (Stratificata)</td>\n                    <td>Esecuzione \"Inefficiente\"</td>\n                </tr>\n                <tr>\n                    <td>Semplice Realizzazione</td>\n                    <td>Difficile Organizzazione dei diritti sugli stati</td>\n                </tr>\n                <tr>\n                    <td><strong>Semplice Debugging</strong></td>\n                </tr>\n            </tbody>\n        </table>\n        <h3 class=\"subtitle is-4\"> Macchine Virtuali </h3>\n        <img src=\"../../immagini/SO/img3_2.png\" alt=\"\">\n        <h3 class=\"subtitle is-4\"> Tecnica Micro-Kernel</h3>\n        <p>Un'alternativa al sistema a livelli è la <strong>tecnica micro-kernel</strong>. <br>\n        Il micro-kernel avrà il compito di gestire:\n        <ul>\n            <li>Processi</li>\n            <li>Memoria</li>\n            <li>Comunicazione (Scambio di messaggi)</li>\n        </ul> \n        La tecnica micro-kernelpremette l'aggiunta di <strong>Moduli Aggiunti</strong>\n        </p>\n        <h3 class=\"subtitle is-4\">SO Customization</h3>\n        <p>\n            I moduli aggiunti <strong>non possono comunicare tra di loro</strong> in quanto viene preso in considerazione che non sempre tutti i moduli aggiuntivi utilizzati\n            saranno scaricati sul SO. <br>\n            Un modulo che richiede l'utilizzo di un altro (Cliente), deve passare attraverso l'SO e chiedere servizi ad un altro modulo (Server). <br>\n            Tutto questo passaggio causa un grande problema di <strong>Disaccoppiamento</strong>. <br>\n            Il più grande problema è causato dalla possibile comparsa di un <strong>Bottleneck</strong> per il kernel, causando un rallentamento dell'esecuzione. <br>\n            Se un modulo crolla, gli altri rimangono intoccati.\n        </p>\n        <h3 class=\"subtitle is-4\">Organizzazione Kernel a Moduli</h3>\n        <p>\n            In questa organizzazione il kernel è <strong>Ridotto</strong>, ma i moduli hanno una loro interfaccia per essere <strong> utilizzati da altri moduli</strong>. <br> {Comando: \"ls mod\"}\n        </p>\n        <h3 class=\"subtitle is-4\">Processi</h3>\n        <p>\n            Un Programma è un <strong>file</strong> che viene <strong>eseguito</strong>. Durante l'esecuzione un programma utilizza risorse RAM e CPU.\n        </p>\n        <img src=\"../../immagini/SO/img3_3.png\" alt=\"\">\n        <p>\n            Ricordare che quando più processi vengono eseguiti in contemporanea, si chiama parallelismo virtuale, in quanto sono eseguiti in \"finta simultanea\".\n        </p>\n        <p>\n            <ul>\n                <li>P1 passa ad attesa e si libera la CPU</li>\n                <li>P2 passa ad esecuzione</li>\n            </ul>\n        </p>\n        <p>\n            Ogno processo viene identificato attraverso il <strong>PID</strong> (Process identifier (numero univoco)). <br>\n            Inoltre ogni porcesso possiede anche il PCB, ovvero una lista che specifica lo stato e tutte le informazioni necessarie a ripristinare il processo, quando viene ripreso.\n        </p>\n        <h3 class=\"subtitle is-4\">Stati dei Processi</h3>\n        <img src=\"../../immagini/SO/img3_4.png\" alt=\"\">\n        <p>\n            <ul>\n               <li>-A termine dell'esecuzione di un processo de-alloca tutto ciò che era assegnato e le dedica ad un altro Processo;</li>\n               <li>-Waiting è in attesa di qualsoa di esterno, nel mentre de-alloca le sue risors;</li>\n               <li>*Solo <strong>alucuni </strong>sistemi operativi possono <strong>sottrarre CPU</strong> ad un elemento in <strong>Esecuzione.</strong></li>\n            </ul>\n        </p>\n        <h3 class=\" subtitle is-4\"> Context Switch</h3>\n        <p>\n            Se un processo P1 viene interrotto , la parte già eseguita viene <strong>Salvata nel PCB</strong>, dove verrà poi riottennuta quando dovrà riprendere. <br>\n            Nel PCB si trovano tutti i registri da recuperare per riprendere in futuro l'esecuzione dal punto in cui si era interrotta. <br>\n        </p>\n        <p><strong>Transizione da Running a Terminato </strong></p>\n        <ul>\n            <li>-Un processo termina a causa di una SysCall (Terminazione Naturale SysCallExit);</li>\n            <li>-In caso di Errore --> SysSall:Abort;</li>\n            <li>-Processo \"uccide  un altro processo\" --> SysCall:Kill;</li>\n            <li>Utente uccide un processo --> SysCall:</li>\n        </ul>\n        <p> <strong> Transizione da Running a Waiting (4 casi)</strong></p>\n        <ol>\n            <li>Invocazione operazione I/O;</li>\n            <li>Sospensione Volontaria;</li>\n            <li>Sospensione in attesa di un evento;</li>\n            <li>Sincronizzazione (Semafori)</li>\n        </ol>\n        <p> \n        <strong> Strutture di Dati di Supporto</strong>\n        </p>\n        <ol>\n            <li>Ready: Nella coda ready;</li>\n            <li>I/O: Nella coda dispositivo (1 per dispositivo);</li>\n            <li>Sincronizzazione semafori: Nella coda Semafori;</li>\n        </ol>\n        <h3 class=\"subtitle is-4\">Scheduling</h3>\n        <p>\"Identificare il prossimo processo a cui assegnare una risorsa\"</p>\n        <p>3 Tipi:</p>\n        <ul>\n            <li>-Scheduling a lungo termine;</li>\n            <li>-Scheduling a medio termine;</li>\n            <li>-Scheduling a corto termine;</li>\n        </ul>\n    </div>\n</template>\n<script>\nimport { VueMathjax } from \"vue-mathjax-next\";\n\nexport default {\n  name: \"SistemiOperativi\",\n  components: {\n    \"vue-mathjax\": VueMathjax,\n  },\n  data() {\n    return {\n      formula: \"$$x = {-b \\\\pm \\\\sqrt{b^2-4ac} \\\\over 2a}.$$\",\n    };\n  },\n  methods: {\n    jump(h) {\n      document\n        .getElementById(h)\n        .scrollIntoView({ block: \"nearest\", behavior: \"smooth\" });\n    },\n  },\n};\n</script>\n<style>\nli {\n  text-align: left;\n}\nh3 {\n  background-color: aliceblue;\n  width: fit-content;\n  padding: 2px;\n  margin-top: 10px;\n}\nh4 {\n  background-color: whitesmoke;\n  width: fit-content;\n  padding: 2px;\n  margin-top: 10px;\n}\n</style>"]},"metadata":{},"sourceType":"module"}